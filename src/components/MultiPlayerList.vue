<!-- a Vue component consists of a template, a Vue 'class' (script), and style -->
<template>
  <div class="mpl">
    <ul class="mpl-list">
      <!-- recommended to split mutli-attrib tags over multiple lines -->
      <li
        v-for="k in kickers"
        :key="k.id">
          {{k.name}} - {{k.stat}}
       </li>
    </ul>
    <!--
      kebab-case is recommended in dom templates because works better with html case insensitivity,
      but kebab-case will match with PascalCase-named registered components too, so component could
      be named PlayerList, and using <player-list> here will still work.
      An empty element is recommended (eg <player-line></player-line>) as it indicates the element does/will
      have content.  However if being compiled by babel+webpack a closed element (eg <player-line/>) can be
      used as the transpiliation will sort it out for you.
     -->
    <player-line/>
    <button @click="addPlayer">Add another kicker (via event to parent which updates props)</button>
    <button @click="addPlayerViaBus">Add another kicker (via event bus)</button>
  </div>
</template>

<script>
// import local components
import PlayerLine from './PlayerLine.vue'
import {bus} from '../main.js'

// export a default object from this file... ES6
export default {
  // register local components
  components: {
    'player-line': PlayerLine
  },

  // Announce we want to receive props (from parent component) - name is same as would be in data.
  // In this case validation is used to indictae eg prop is mandatory and must be an array.
  // Alternatively, without validation, an abreviated syntax of  props: ['prop1', 'prop2']  can be used.
  //
  // When a JS reference type (array or object) is passed liked this, it is a reference to the object in the
  // parent (cf a JS primitive type like boolean, string or number) - so beware when changing contained values.
  props: {
    kickers: {
      required: true,
      type: Array
    }
  },

  // shorthand for  data: function()...  ES6
  data () {
    return {
      // kickers: []   getting this from props
    }
  },

  methods: {
    addPlayer() {
      // emit an event up to the parent
      this.$emit('addPlayer', 'New guy');
    },
    addPlayerViaBus() {
      // emit an event via the bus (created in main.js)
      bus.$emit('addPlayerViaBus', 'New gal');
    }
  },

  // a life-cycle hook; called when this object is created
  created() {
    // listen to an event on the bus
    // use fat arrow function ... ES6
    bus.$on('addPlayerViaBus', (data) => {
      this.kickers.push({
        id: this.kickers.length + 1,
        name: data,
        stat: 14.5
      })
    })
  }
}
</script>

<!--
  All styles are added globally to the rendered html head tag.

  With 'scoped' the style gets applied only to elements in this component.
  It does this by adding a unique data attribute to all elements generated by this component
  and using that in the style selector.  This is the recommended approach (except for root components).

  Witout scoped all styles just get added to the page with no data selector, and so last in wins.

  It is recommened to NOT use element selectors (eg button) with scoped, use class selectors (eg .btn_thing).
-->
<style scoped lang="scss">
.mpl {
  background-color: blue;
}

ul.mpl-list {
  display: flex;
  flex-wrap: wrap;
  list-style-type: none;
  padding: 0;
}

ul.mpl-list li {
  flex-grow: 1;
  flex-basis: 200px;
  padding: 1px;
  border: thin black solid;
}
</style>
